Now we'll discuss Kubernetes
Object Management. All Kubernetes objects
are identified by a unique name and
a unique identifier. Let's return once again
to our example in which we want three nginx web servers
running all the time. Well, the simplest way
would be to declare three pod objects and
specify their state. For each, a pod must be created and an nginx container
image must be used. Let's see how we declare this. You define the objects
you want Kubernetes to create and maintain
with manifest files. These are ordinary text files. You may write them in
YAML or Json format. YAML is more human readable
and less tedious to edit, and we will use it throughout
this specialization. This YAML file defines
a desired state for a pod. Its named under a specific
container image for it to run. Your manifest files have
certain required fields. API version describes
which Kubernetes API version is used to create the object. The Kubernetes
protocols version so as to help maintain
backwards compatibility. Kind, defines
the object you want, in this case a pod, and metadata helps identify
the object using name, unique id, and
an optional namespace. You can define
several related objects in the same YAML file, and it is a best
practice to do so. One file is often easier
to manage than several. Another even more important tip. You should save your YAML files in version controlled
repositories. This practice makes it
easier to track and manage changes and to back out
those changes when necessary. It's also a big help
when you need to recreate or restore a cluster. Many GCP customers use cloud source repositories
for this purpose. Because that service lets them
control the permissions of those files in the same way
as their other GCP resources. When you create
a Kubernetes object, you name it with a string. Names must be unique. Only one object of
a particular kind can have a particular name at the same time in
a Kubernetes namespace. However, if an object is deleted, it's name can be reused. Alphanumeric characters, hyphens, and periods are
allowed in the names with a maximum character
length of 253. Each object generated throughout
the life of a cluster has a unique ID
generated by Kubernetes. This means that no two
objects will have the same UID throughout
the life of a cluster. Labels are key value pairs
with which you tag your objects during
or after their creation. Labels help you identify and organize objects and
subsets of objects. For example, you could
create a label called app, and give as its value, the application of which
this object is a part. In this simple example, a deployment object is labeled with three
different key values. Its application, its environment, and which stack it
forms a part of. Various contexts offer
ways to select Kubernetes resources by their labels. In this specialization,
you will spend plenty of time with
the kubectl command. Here's an example
of using it to show all the parts that contain
a label called app, with a value of nginx. Label selectors are
very expressive. You can ask for all the resources that have a certain
value for a label, or those that don't
have a certain value, or even all of those that have a value in a set you supply. So one way to bring three nginx web servers into being would be to declare
three pod objects, each with its own
section of YAML. Kubernetes default
scheduling algorithm, prefers to spread the workload evenly across the nodes
available to it. So we'd get a situation
like this one. Looks good, doesn't
it? Maybe not. Suppose I want
200 more nginx instances. Managing 200 more sections of YAML sounds very inconvenient. Here's another problem. Pods don't heal or repair themselves and they're
not meant to run forever. They are designed to be
ephemeral and disposable. For these reasons, there are better ways to manage what you run in Kubernetes than
specifying individual pods. You need a set up
like this to maintain an applications high availability along with horizontal scaling. So how do you tell Kubernetes to maintain the desired state
of three nginx containers? We can instead declare
a controller object, whose job is to manage
the state of the pods. Some examples of these objects; deployments, StatefulSets,
DaemonSets and jobs. We'll meet all of these
in our specialization. Deployments are a great choice for long-lived
software components, like web servers, especially when we want to
manage them as a group. In our example, when kube-scheduler schedules
pods for a deployment, it notifies the Kube API server. These changes are constantly
monitored by controllers, especially by
the deployment controller. The deployment
controller will monitor and maintain three nginx pods. If one of those pods fails, the deployment controller
will recognize the difference between
the current state and the desired state, and will try to fix it
by launching a new pod. Instead of using
multiple YAML manifest or files for each pod, you used a single deployment YAML to launch three replicas
of the same container. A deployment ensures that a defined set of pods is
running at any given time. Within its objects specs, you specify how many
replica pods you want, how pods should run, which containers should
run within these pods, and which volume
should be mounted. Based on these templates, controllers maintain the pods desired state within a cluster. Deployments can also do
a lot more than this, which you'll see
later in the course. It's very probable that you'll be using a single cluster
for multiple projects. At the same time, its
essential to maintain resource quotas based
on projects or teams. By the way, when I
say projects here I mean projects in
the informal sense of the word. Things you and your colleagues
are working on. Each Kubernetes clusters
is associated with one GCP project in the formal
sense of the word project. That's how IM policies apply to it and how
you'll build for it. So how do you keep everybody's work on your cluster
tidy and organized? Kubernetes allows you to abstract a single physical cluster into multiple clusters
known as namespaces. Namespaces provide
scope for naming resources such as pods,
deployments, and controllers. As you can see in this example, there are three namespaces
in this cluster. Test, stage, and prod. Remember that you cannot have duplicate object names
in the same namespace. You can create three pods
with the same name, nginx in this case, but only if they don't
share the same namespace. If you attempt to create
another pod with the same name, nginx pod in namespace test,
you won't be allowed. Object names need only be
unique within a namespace, not across all namespaces. Namespaces also let you implement resource quotas
across the cluster. These quotas define limits for resource consumption
within a namespace. They're not the same
as your GCP quotas, which we discussed in
an earlier module. These quotas apply specifically to the Kubernetes cluster
they're defined on. You're not required to use namespaces for
your day-to-day management. You can also use labels. Still, namespaces
are a valuable tool. Suppose you want to spin up a copy of a deployment
as a quick test. Doing so in a new namespace makes it easy and free of
name collisions. There are three initial
namespaces in the cluster. The first is a default namespace, for objects with
no other namespace defined. Your workload resources will use this namespace by default. Then there is
the Kube-system namespace for objects created by
the Kubernetes system itself. We'll see more of
the object kinds in this diagram elsewhere
in this specialization. When you use the kubectl
command, by default, items in the Kube-system
namespace are excluded, but you can choose to view
its contents explicitly. The third namespace is the Kube-public namespace for objects that are publicly
readable to all users. Kube-public is a tool for
disseminating information to everything running
in a cluster. You're not required to use it, but it can come in handy, especially when
everything running in a cluster is related
to the same goal, and needs information in common. You can apply a resource
to a namespace when creating it using
a command line namespace flag. Or, you can specify a namespace in the YAML file
for the resource. Whenever possible, apply namespaces at
the command line level. This practice makes your YAML
files more flexible. For example, someday,
you might want to create two completely
independent instances of one of your deployments, each in its own namespace. This is difficult
if you have chosen to embed namespace names
in your YAML files.